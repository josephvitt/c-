/*
指针变量的初始化
1.语法形式
存储类型 数据类型 *指针名 = 初始地址
2.例：
int *pa = &a;
3.注意事项
    1.用变量地址作为初始值，该变量必须在指针初始化之前已声明过，
    且变量类型应该与指针类型一致
    2.可以用一个已有合法值的指针去初始化另一个指针变量。
    3.不要用一个非静态变量去初始化static指针。


指针变量的赋值运算
1.语法形式
指针名 = 地址
2.注意
    ”地址“中存放的数据类型与指针类型必须相符
    向指针变量赋的值必须是地址常量或变量，不能是普通整数
3.例如：
    通过地址运算符”&“ 求得已经定义的变量和对象的起始地址
    动态内存分配成功时返回的地址
4.例如：
    整数0可以赋值给指针，表示空指针
5.允许定义或声明指向 void 类型的指针。
该指针可以被赋予任何类型对象的地址。
例： void *general;

指针空值nullptr
1.c++11使用nullptr关键字，是表达更准确，类型安全的空指针。

*/
#include <iostream>
using namespace std;
int main(){
    int i;
    int *ptr = &i;
    i = 10;
    cout << "i= " << i << endl;
    cout << "*ptr= " << *ptr <<endl; 

    //可以声明void类型的指针
    void *pv;
    int ii = 5;

    //void类型指针指向整型变量
    pv = &ii; 
    //void指针转成int指针
    int *point = static_cast<int*>(pv);

    cout << "*point = "<< *point << endl;

    /*
        指向常量的指针；只能读取不能修改
        1.cost指针
        2.不能通过指向常量的指针改变所指对象的值，
        但指针本身可以改变，可以指向另外的对象。

        例：
        int a;
        //p1是指向常量的指针
        const int *p1 = &a;
        int b;
        //正确，p1本身的值可以改变
        p1 = &b;
        //编译时错误，不能通过p1改变所指的对象
        *p1 = 1;

    */

   /*
   指针类型的常量;只读的指针
   1.若声明指针常量，则指针本身的值不能被改变。
   2.例
   int a;
   int * const p2 = &a;
   p2 = &b;//错误   p2是指针常量，值不能改变
   */
    return 0;
}