#include <iostream>
using namespace std;
/*
  复制(拷贝)构造函数
  已经存在的对象去初始化一个新对象,可以用他的引用作为函数的参数;
  如果没有定义复制构造,编译器也很默认的生成一个.

  如基本类型的数据:已经有值得变量去重新赋值给同类型的变量

  复制(拷贝)构造函数定义
  1.复制构造函数是一种特殊的构造函数,其形参必须为本类的引用.
    作用是用一个已经存在的对象去初始化同类型的新对象.
  2.class 类名{
      public:
        类名(形参);//构造函数
        类名(const 类名 &对象名);//复制(拷贝)构造函数
    //...
  }

   类名::类(const 类名 &对象名){ //复制构造函数的实现
       函数体
   }

   注意:const
   接受引用参数的数据,它是一个双向传递,
   函数体中如果对这个形参引用做了任何的修改,那么实参也会被同步修改的,显然这不是写复制构造函数的目的.
   目的是形参引用所指的那个对象去初始化新对象,但绝不希望在这个初始化的过程中,把原有的形参对象给修改.
   加上const,是常引用,不能用它的引用对他指向的数据进行修改.保证实参的安全性.

   //调用复制(拷贝)构造函数的三种情况
   1.定义一个对象时,以本类另一个对象作为初始值,发生复制(拷贝)构造;
   2.如果函数的形参是类的对象,调用函数时,将使用实参对象初始化形参对象,发生复制(拷贝)构造;
   3.如果函数的返回值是类的对象,函数执行完成要返回主调函数了,将使用return语句中的对象初始化一个临时的无名对象,
   传递给主调函数,发生复制(拷贝)构造;
   这种情况也可以通过移动构造避免不必要的复制

   隐含的复制构造函数
   1.如果程序员没有为类声明拷贝初始化构造函数,则编译器自己生成一个隐含的复制构造函数
   2.这个构造函数执行的功能是:用初始值对象的每个数据成员,初始化将要建立的对象的对应的数据成员.


   类中有指针的时候,这时候就不够用了.

    "=delete"
    如果不希望对象被复制构造
    1.c++98做法:将复制构造函数声明为private,并且不提供函数的实现
    2.c++11做法:用"=delete""来指示编译器不生成默认复制构造函数


 */
class Point{
    Point(int xx=0,int yy=0){x == xx;y=yy;} //构造函数,内联
    Point(const Point &p) = delete;//指示编译器不生成默认复制构造函数
    private:
        int x,y;
};
 int main(){

 }
 